package lib

import (
	"gopkg.in/yaml.v2"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
	"unicode"
)

// Template for Go structs
const structTemplate = `
// Code generated by config generator. DO NOT EDIT.
package config
import (
	"context"
	"github.com/cloudimpl/next-coder-sdk/polycode"
)

func FromApp(ctx context.Context)*AppConfig{
	cfg := &AppConfig{}
	polycode.FromAppConfig(ctx, cfg)
	return cfg
}


{{- range .Structs }}
type {{ .Name }} struct {
{{- range .Fields }}
    {{ .Name }} {{ .Type }} ` + "`yaml:\"{{ .YAMLName }}\"`" + `
{{- end }}
}

{{ end }}

`

// StructField represents a single field in a Go struct
type StructField struct {
	Name     string
	Type     string
	YAMLName string
}

// Struct represents a Go struct with its fields
type Struct struct {
	Name   string
	Fields []StructField
}

// Helper function to convert map[interface{}]interface{} to map[string]interface{}
func convertMap(m interface{}) interface{} {
	switch x := m.(type) {
	case map[interface{}]interface{}:
		converted := make(map[string]interface{})
		for k, v := range x {
			converted[k.(string)] = convertMap(v) // Recursively convert values
		}
		return converted
	case []interface{}:
		for i, v := range x {
			x[i] = convertMap(v)
		}
	}
	return m
}

// TitleCase converts the first letter of each word to uppercase
func titleCase(input string) string {
	return strings.Map(func(r rune) rune {
		return unicode.ToTitle(r)
	}, input[:1]) + strings.ToLower(input[1:])
}

// GenerateStructName converts a YAML section name to a Go struct name
func generateStructName(section string) string {
	return titleCase(section)
}

// GenerateFieldName converts a YAML key to a Go field name (CamelCase)
func generateFieldName(key string) string {
	return titleCase(strings.ReplaceAll(key, "-", ""))
}

// GenerateFieldType infers the Go type from a YAML value
func generateFieldType(value interface{}) string {
	switch reflect.TypeOf(value).Kind() {
	case reflect.Map:
		return "map[string]interface{}"
	case reflect.Slice:
		return "[]interface{}"
	case reflect.String:
		return "string"
	case reflect.Int, reflect.Int64:
		return "int"
	case reflect.Bool:
		return "bool"
	default:
		return "interface{}"
	}
}

// ParseYAML parses the YAML structure and returns a slice of structs
func parseYAML(data map[string]interface{}, structName string) []Struct {
	var structs []Struct
	fields := []StructField{}

	// Iterate through the map to generate fields
	for key, value := range data {
		fieldName := generateFieldName(key)
		fieldType := generateFieldType(value)

		if reflect.TypeOf(value).Kind() == reflect.Map {
			// If it's a map, generate a nested struct
			nestedStructName := generateStructName(key)
			structs = append(structs, parseYAML(value.(map[string]interface{}), nestedStructName)...)
			fieldType = nestedStructName
		}

		fields = append(fields, StructField{
			Name:     fieldName,
			Type:     fieldType,
			YAMLName: key,
		})
	}

	structs = append(structs, Struct{
		Name:   structName,
		Fields: fields,
	})

	return structs
}

// GenerateCode generates Go code based on parsed structs
func generateConfigCode(structs []Struct) (string, error) {
	tpl, err := template.New("structs").Parse(structTemplate)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	err = tpl.Execute(&result, map[string]interface{}{
		"Structs": structs,
	})

	return result.String(), err
}

func GenerateConfig(appPath string) error {
	configFolder := filepath.Join(appPath, "config")
	configFile := filepath.Join(configFolder, "app-config.go")
	yamlFile := filepath.Join(appPath, "application.yml")

	var yamlData interface{}
	data, err := os.ReadFile(yamlFile)
	if err != nil {
		println("error reading yml file")
		return err
	}

	if os.IsNotExist(err) {
		println("application.yml not found. generating empty config...")
		yamlData = make(map[string]interface{})
	} else {
		err = yaml.Unmarshal(data, &yamlData)
		if err != nil {
			println("error unmarshalling yml")
			return err
		}
	}

	yamlData = convertMap(yamlData)
	structs := parseYAML(yamlData.(map[string]interface{}), "AppConfig")

	goCode, err := generateConfigCode(structs)
	if err != nil {
		println("error generating code")
		return err
	}

	err = os.MkdirAll(configFolder, 0755)
	if err != nil {
		println("error creating folder")
		return err
	}

	err = os.WriteFile(configFile, []byte(goCode), 0644)
	if err != nil {
		println("error writing file")
		return err
	}

	return nil
}
